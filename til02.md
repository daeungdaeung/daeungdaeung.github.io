# 백준 2559 수열

[문제링크](https://www.acmicpc.net/problem/2559)

난 파이썬으로 문제를 풀었지.

이 문제의 핵심은 효율적으로 코드를 짤 수 있느냐였다.

실제로 문제 자체를 이해하기에는 어렵지 않고 매우 쉬웠다...

하지만 극강의 효율을 요구하므로, 이 문제를 패스하려면 **좋은 아이디어**가 필요했다.

**아이디어**

> 배열 [1, 2, 3, 4, ...., 1000]이 있다고 가정하자.
>
> *현재는 배열안의 원소가 오름차순으로 되어있지만, 랜덤이라고 생각했으면 좋겠다.*
>
> 우리가 배열안에서, **10개의 연속된 원소의 합 중에서 가장 큰 값을 구하려면** 보통 [1, 2, 3, 4, 5, 6, 7, 9, 10]을 모두 더하고 [2, 3, 4, 5, 6, 7, 8, 9, 10, 11]을 모두 더하여 누가 더 큰지 판별한다. 이것을 배열의 끝에 닿을때까지 반복할 것이다.
>
> 하지만 이렇게 하면 매번 10개씩 더해야 하므로 비효율적이다. ~~만일 배열의 크기가 더 크고 주어진 문제에서 연속된 원소의 개수가 더 크다면 비효율성은 어마무시하게 커질 것이다.~~
>
> 이 비효율성을 개선하려면 기존 배열의 합을 재활용 하는 것이다. 
>
> 순서는 아래와 같다.
>
> - [1, 2, ..., 10] => 45 ***얘는 기존 배열의 합***
>
> - [2, 3, ...., 10] => 44 ***얘는 기존 배열의 합에서 첫 원소 값을 제거***
>
> - [2, 3, ...., 11] => 55 ***위의 원소 합에서 그 다음 원소 값을 추가***
>
> 이렇게 하면 매번 10개 원소를 다 더하려고 하지 않아도 된다. 물론 100개의 총합중에서 가장 큰것을 구할때도 딱 두번만 계산하면 된다. ~~이해가 좀 어렵다면 직접 배열을 손으로 그려서 따라가보면 스스로 깨우칠 것이라 굳게 믿는다.~~
>
> **나는 스스로 생각해내지 못했었다.** 이 아이디어를 발견했을 때 온몸에 소름 돋았다. *개쩔어서.*

### 백준에 제출하고 통과한 코드 &#128587;

```python
n, k = map(int, input().split())
temperatures = list(map(int, input().split()))
max_v = sum(temperatures[0:k])
tmp_v = max_v
idx = 0
# 매번 리스트 슬라이싱으로 합을 구하는것보다
# 기존의 합에서 맨 앞의 원소를 빼고
# 맨뒤의 원소를 더하면
# 속도가 더 빠를것으로 생각된다.
while idx+k <= n-1:
    tmp_v -= temperatures[idx]
    tmp_v += temperatures[k+idx]
    if max_v < tmp_v:
        max_v = tmp_v
    idx += 1

print(max_v)
```

